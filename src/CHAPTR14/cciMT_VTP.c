/* Chapter 14. cciMT_VTP. - Will not build on VS2005. Requires NT6
	Multithreaded simplified Caesar cipher file conversion.
	Use threads and a thread pool as an alternative to overlapped I/O. 
	The resulting code is MUCH simpler. */
/* cciMT_VTP file1 file2 */
#include "Everything.h"

#define MAX_OVRLP 4  /* Number of worker threads (CPU count is generally best - Exercise: Add a command line option */
#define RECORD_SIZE 16384  /* 16K block size - Input file size should be
                            * a multiple of MAX_OVRLP * RECORD_SIZE 
                            * 16K is optimal in some simple tests
                            * You may want to add a command line option. See comments in cciMT. */
#define SFP_ERROR 0xFFFFFFFF  /* Error getting size of file  */

typedef struct TH_ARG_T {
	volatile HANDLE hIn;
	volatile HANDLE hOut;
	volatile LARGE_INTEGER FileSize;
} TH_ARG;
TH_ARG ThArg[MAX_OVRLP];  // Globally accessible for use by the threadpool callback function.

VOID CALLBACK ReadWrite (PTP_CALLBACK_INSTANCE, PVOID, PTP_WORK);
int WorkerId = 0;	// Unique ID computed by each callback instance
DWORD shift;

/**** CHALLENGE: Improve the file handle closing when an operation fails in a thread.
      Using ReportException rather than ReportError may help. Alos, see cciMT ****/
int _tmain (int argc, LPTSTR argv[])
{
	HANDLE hSize;
	DWORD i;
    LARGE_INTEGER inputFileSize, outputFileSize;
    PTP_WORK pWorker;

    if (!WindowsVersionOK (6, 0)) 
        ReportError (_T("This program requires Windows NT 6.0 or greater"), 1, TRUE);

	if (argc != 4)
		ReportError (_T("Usage: cciMT_VTP shift file1 file2"), 1, FALSE);

	shift = _ttoi(argv[1]);
    /* Find the input file size */
    hSize = CreateFile (argv[2], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
			        FILE_ATTRIBUTE_NORMAL, NULL);
 	if (hSize == INVALID_HANDLE_VALUE) 
		ReportError (_T ("Fatal error opening input file to get its size."), 2, TRUE);
	if (!GetFileSizeEx (hSize, &inputFileSize)) {
		CloseHandle (hSize);
        ReportError (_T ("Fatal error sizing input file."), 2, TRUE);
	}
    CloseHandle (hSize);

    /* Create the output file with the correct size 
     * NOTE: It is easiest to create the output file before the thread functions execute
     * If you do not create the file here, be sure to use OPEN_ALWAYS in the thread functions */
    outputFileSize.QuadPart = inputFileSize.QuadPart;
    hSize = CreateFile (argv[3], GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 
                            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
 	if (hSize == INVALID_HANDLE_VALUE) 
		ReportError (_T ("Fatal error opening output file to set its size."), 2, TRUE);
    /* Setting the output file size is not absolutely necesary but is convenient in case, for
     * example, there is insufficient disk space. Otherwise, one of the thread functions would
     * fail. */
    if (!SetFilePointerEx (hSize, outputFileSize, NULL, FILE_BEGIN)) {
		CloseHandle (hSize);
		ReportError (_T ("Fatal error setting output file pointer."), 2, TRUE);  
	}
	if (!SetEndOfFile (hSize)) {
		CloseHandle (hSize);
		ReportError (_T ("Fatal error sizing output file."), 2, TRUE);
	}
    CloseHandle (hSize);

    pWorker = CreateThreadpoolWork (ReadWrite, _T("Worker Thread Pool"), NULL);
    if (NULL == pWorker)
        ReportError (_T("CreateThreadpoolWork failed"), 2, TRUE);

    /* Create all the conversion read-write threads */
	for (i = 0; i < MAX_OVRLP; i++) {

		/* Note: If you create just two handles (one for input, one for output)
			and then use DuplicateHandle to create individual handles for each
			thread (i.e., ThArg[i].hOut, etc. are generated by DuplicateHandle),
			you'll have problems. It appears is if ReadFile and WriteFile are
			not thread safe when dealing with duplcated handles. This is the case
			even if you protect the ReadFile and WriteFile with a CRITIAL_SECTION
			and even if you use the no buffering and write through flags. 
			As an exercise, try using duplecated handles. You will see errors if
			you compare the output file with one generated with a correct
			cciXX program. */
		ThArg[i].hIn = CreateFile (argv[2], GENERIC_READ,
			FILE_SHARE_READ, NULL, OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL, NULL);
 		if (ThArg[i].hIn == INVALID_HANDLE_VALUE) 
			ReportError (_T ("Fatal error opening input file."), 2, TRUE);
    	ThArg[i].FileSize.LowPart = inputFileSize.LowPart;
		ThArg[i].FileSize.HighPart = inputFileSize.HighPart;
		ThArg[i].hOut = CreateFile (argv[3], GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL /*| FILE_FLAG_NO_BUFFERING | FILE_FLAG_WRITE_THROUGH*/, NULL);
		/* Note: DO NOT USE THE TWO COMMENTED OUT FLAGS AS THEY REQUIRE THAT THE OUTPUT
			BUFFER LENGTHS BE SECTOR SIZE MULTIPLES (THE WRITE WILL FAIL ) */
		if (ThArg[i].hOut == INVALID_HANDLE_VALUE) 
			ReportError (_T ("Fatal error opening output file."), 3, TRUE);
	}

    /* Submit the work to the thread pool				*/
	for (i = 0; i < MAX_OVRLP; i++) {
        SubmitThreadpoolWork (pWorker);
    }

	/* Worker threads are all running. Wait for them 	*/
	/* to complete and accumulate the results			*/
    /* Wait for the thread pool to complete				*/
    WaitForThreadpoolWorkCallbacks (pWorker, FALSE);
   	CloseThreadpoolWork (pWorker);

	for (i = 0; i < MAX_OVRLP; i++) {
        FlushFileBuffers (ThArg[i].hOut); 
		CloseHandle (ThArg[i].hOut); 
		CloseHandle (ThArg[i].hIn);
	}
	return 0;
}

/* Thread worker callback function to process a single file		*/
VOID CALLBACK ReadWrite (PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WORK Work)
{
    /* Threadpool callback function to perform cci conversion on one "stripe" within a file
     * pThArg->ThreadNum is the "stripe number" (0, 1, ..., MAX_OVRLP)
     * Stripe i processes logical records i, i+MAX_OVRLP, i+2*MAX_OVRLP, ... 
     * RECORD_SIZE defines the logical record size */

  	CHAR rawRec[RECORD_SIZE];
	CHAR cciRec[RECORD_SIZE];
	LARGE_INTEGER CurPosIn, CurPosOut;
	DWORD i, nRead = 1, nWrite, iTh;
	HANDLE hIn, hOut;
	TH_ARG * pThArg;
	OVERLAPPED OvRead = {0, 0, 0, 0, NULL}, OvWrite = {0, 0, 0, 0, NULL};

	iTh = InterlockedIncrement (&WorkerId) - 1;
	pThArg = &ThArg[iTh];

	hIn = pThArg->hIn; hOut = pThArg->hOut;

	CurPosIn.QuadPart = (LONGLONG) RECORD_SIZE * iTh;
	CurPosOut.QuadPart = (LONGLONG) RECORD_SIZE * iTh;
	while (CurPosIn.QuadPart < pThArg->FileSize.QuadPart) {
		OvRead.Offset      = CurPosIn.LowPart;
		OvRead.OffsetHigh  = CurPosIn.HighPart;
		OvWrite.Offset     = CurPosOut.LowPart;
		OvWrite.OffsetHigh = CurPosOut.HighPart;
		
		if (!ReadFile (hIn, rawRec, RECORD_SIZE, &nRead, &OvRead) || nRead > RECORD_SIZE) 
            ReportError (_T("Error reading input file"), 8, TRUE);

		for (i = 0; i < nRead; i++)
			cciRec [i] = (rawRec[i] + shift) % 256;
		
		if (!WriteFile (hOut, cciRec, nRead, &nWrite, &OvWrite) || nWrite != nRead)
			ReportError (_T("Error writing output file"), 9, TRUE);
        
        CurPosIn.QuadPart += (LONGLONG) RECORD_SIZE * MAX_OVRLP;
		CurPosOut.QuadPart += (LONGLONG) RECORD_SIZE * MAX_OVRLP;
	}

	return;
}
